<#@ template language="C#" visibility="internal" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: <#= Environment.Version #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

"use strict";

// Interfaces
<# foreach(var @interface in this.Interfaces) { #>

export interface <#= @interface.Name #> {

<#    foreach(var member in @interface.Members) { #>
	<#= member.Name#>?: <#= GetTypeScriptFieldTypeName(member.Type) #>;
<#    } #>
}
<# } #>


// Enums
<# foreach(var @enum in this.Enums) { #>

export enum <#= @enum.Name #> {
<#    foreach(var member in @enum.Members) { #>
	<#= member.Name #> = <#= (int)Enum.Parse(member.Type, member.Name) #>,
<#    } #>
}
<# } #>
<#+
	/// <summary>
	/// Returns a corresponding TypeScript type for a given .NET type
	/// </summary>
	public static string GetTypeScriptFieldTypeName(Type type)
	{
		var numberTypes = new HashSet<Type>
		{
			typeof(sbyte), typeof(byte), typeof(short),
			typeof(ushort), typeof(int), typeof(uint),
			typeof(long), typeof(ulong), typeof(float),
			typeof(double), typeof(decimal)
		};
		var stringTypes = new HashSet<Type>
		{
			typeof(char), typeof(string), typeof(Guid)
		};

		var result = "";
		var isCollectionType = false;
		// Check if it is a generic. We support only generics which are compatible with IEnumerable<T> and have only one generic argument
		if (type.IsGenericType) {
			if (!typeof(IEnumerable<object>).IsAssignableFrom(type) && type.GetGenericArguments().Length > 1) {
				throw new Exception(string.Format("The generic type {0} must implement IEnumerable<T> and must have no more than 1 generic argument.", type.FullName));
			}
			// strip the generic type leaving the first generic argument
			type = type.GetGenericArguments()[0];
			isCollectionType = true;
		}

		// Check if it is a primitive type
		if (numberTypes.Contains(type)) result = "number";
		else if (stringTypes.Contains(type)) result = "string";
		else if (type == typeof(bool)) result = "boolean";
		// It is enum/class/struct -> return its name as-is
		else result = type.Name;

		if(isCollectionType) result += "[]";

		return result;
	}
#>